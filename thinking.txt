同步、异步区别：同步是有时序性的进行每个步骤，异步则不需要，有人告诉它结果，如回调；
阻塞、非阻塞区别：着重点在于程序在遇到阻塞和非阻塞之后的状态来定性；阻塞则当前程序挂起，非阻塞立即返回结果


pom中的dependencies和dependencymanagement区别：
	dependencies指定了依赖项，即子pom文件没有依赖某个三方包，也会继承父pom中dependencies所定义的依赖项
	dependencymanagement则是对版本的统一管理，子类可以只需要写依赖项的groupId和artifactId即可，版本号与dependencymanagement定义的相对应；

git push -u:此u为upstream;即指定push的远程仓库；因为跟踪的远程仓库不只一个；


volatile:轻量级锁，在每个线程当中会包含副本，但如果写的话会直接从本地缓存中刷新到主存中，而读的话jmm（java memory model）会把该线程的本地内存置为无效；
即被volatile描述的属性在多线程间是原子可见的；但对其操作未必是原子的；
volatile所修饰的属性具有happens before准则；即保证该属性在多个线程间是内存可见的；
同时volatile在读写在编译期时会在指令序列中插入内存屏障来禁止特定类型的处理器重排序，
1，当第二个操作是volatile写时，不管第一个操作是什么，都不能重新排序，这个规则保证volatile写之前的操作不会被编译器重新排序到volatile写之后
2，当第一个操作是volatile读时，不管第二个操作是什么，都不能重新排序，这个规则保证volatile读之前的操作不会被编译器重新排序到volatile读之前；
3，当第一个操作是volatile写，第二个操作是volatile读，不能重新排序；

为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：

在每个volatile写操作的前面插入一个StoreStore屏障：禁止上面的普通写操作和下面的volatile写操作重排序。
在每个volatile写操作的后面插入一个StoreLoad屏障：禁止和下面可能有的读/写操作重新排序。
在每个volatile读操作的后面插入一个LoadLoad屏障：禁止下面的读操作和上面的volatile读操作重排序。
在每个volatile读操作的后面插入一个LoadStore屏障：禁止下面的写操作和上面的volatile读操作重排序。
上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。

同时产生疑惑的有static：是每个实例是原子可见的且唯一的；与volatile有点歧义；
而sychronized同步语句块是防止两个线程同时对某个变量有着控制权，其所修改的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile

java string itern()方法调用会先去字符串常量池中查找相应的字符串，如果字符串不存在，就会在字符串常量池中创建该字符串然后再返回；
java6中的常量池放在perm空间内，而java7中的常量池放在heap空间；


